## let them set their own y-axes
facet_grid(measure ~ ., scales = "free_y") +
## plot both as a line
geom_point() + geom_line()
mdata %>%
#mdata$cases
# using an additive classical decomposition model
model(classical_decomposition(cases, type = "additive")) %>%
## extract the important information from the model
components() %>%
## generate a plot
autoplot()
#Installing package required for installing libraries
install.packages("pacman")
library(readxl)
ts_data <- read_excel("monthlydate_data.xlsx")
library(readxl)
ts_data <- read_excel("monthlydate_data.xlsx")
View(ts_data)
glimpse(ts_data)
ts_data <- ts_data %>%
clean_names() %>%
rename( m_tempmax = tempmax,
m_tempmin = tempmin,
m_temp = temp,
m_humid = humidity,
m_precip = precip,
m_precov = precipcover)
mdata$state <- as.factor(mdata$state)
mdata$year <- as.Date(mdata$date)
mdata$cases <- as.numeric(mdata$cases)
mdata$year <- as.Date(mdata$date, format = "%Y-%m-%d")
ts_data$state <- as.factor(mdata$state)
ts_data$year <- as.Date(mdata$date, format = "%Y-%m-%d")
ts_data$state <- as.factor(ts_data$state)
ts_data$year <- as.Date(ts_data$date, format = "%Y-%m-%d")
ts_data$cases <- as.numeric(ts_data$cases)
glimpse(ts_data)
View(ts_data)
library(readxl)
ts_data <- read_excel("monthlydate_data.xlsx")
View(ts_data)
glimpse(ts_data)
#Data Cleaning----------------------------------------------------------------------------------
ts_data <- ts_data %>%
clean_names() %>%
rename( m_tempmax = tempmax,
m_tempmin = tempmin,
m_temp = temp,
m_humid = humidity,
m_precip = precip,
m_precov = precipcover)
ts_data$state <- as.factor(ts_data$state)
ts_data$date <- as.Date(ts_data$date, format = "%Y-%m-%d")
ts_data$cases <- as.numeric(ts_data$cases)
describe(ts_data)
mean_cases <- ts_data %>%
group_by(state, date) %>%
summarise(mean_cases = mean(cases)) %>%
print()
ts_data %>% select(!c(date)) %>%
tbl_summary(by = state, statistic = list
(all_continuous() ~ "{mean} ({sd})" ), digits = all_continuous() ~2) %>%
add_p() %>% add_overall()
mean_climate <- ts_data  %>%
group_by(state,date) %>%
summarise( meanm_tempmin = mean(m_tempmin),
meanm_temp = mean(m_temp),
meanm_tempmax = mean(m_tempmax),
meanm_precip = mean(m_precip),
meanm_precov = mean(m_precov),
meanm_humid = mean(m_humid))
print(mean_climate)
data$month_year <- with(ts_data, interaction(date, drop = TRUE))
calculate_group_correlations <- function(ts_data) {
correlations <- ts_data %>%
select(cases, m_tempmin, m_temp, m_tempmax, m_humid, m_precip, m_precov) %>%
correlate(method = "spearman")
return(correlations)
}
#applying the function to create a grouped correlation table by state and year
correlation_table <- ts_data %>%
group_by(state, date) %>%
do(calculate_group_correlations(.))
print(correlation_table)
ts_data %>% select(!c(date)) %>%
tbl_summary(by = state, statistic = list
(all_continuous() ~ "{mean} ({sd})" ), digits = all_continuous() ~2) %>%
add_p() %>% add_overall()
calculate_group_correlations <- function(ts_data) {
correlations <- ts_data %>%
select(cases, m_tempmin, m_temp, m_tempmax, m_humid, m_precip, m_precov) %>%
correlate(method = "spearman")
return(correlations)
}
#applying the function to create a grouped correlation table by state and year
correlation_table <- ts_data %>%
group_by(state, date) %>%
do(calculate_group_correlations(.))
print(correlation_table)
glimpse(ts_data)
mean_cases <- ts_data %>%
group_by(state, date) %>%
summarise(mean_cases = mean(cases)) %>%
print()
library(feasts)
library(tsibble)
ts_data %>%
# using an additive classical decomposition model
model(classical_decomposition(cases, type = "additive")) %>%
## extract the important information from the model
components() %>%
## generate a plot
autoplot()
ts_data %>%
## keep the variables we are interested
select(date, cases, m_temp) %>%
## change your data in to long format
pivot_longer(
## use epiweek as your key
!date,
## move column names to the new "measure" column
names_to = "measure",
## move cell values to the new "values" column
values_to = "value") %>%
## create a plot with the dataset above
## plot epiweek on the x axis and values (counts/celsius) on the y
ggplot(aes(x = date, y = value)) +
## create a separate plot for temperate and case counts
## let them set their own y-axes
facet_grid(measure ~ ., scales = "free_y") +
## plot both as a line
geom_point() + geom_line()
ts_data %>%
## keep the variables we are interested
select(date, cases, m_temp) %>%
## change your data in to long format
pivot_longer(
## use epiweek as your key
!date,
## move column names to the new "measure" column
names_to = "measure",
## move cell values to the new "values" column
values_to = "value") %>%
## create a plot with the dataset above
## plot epiweek on the x axis and values (counts/celsius) on the y
ggplot(aes(x = date, y = value)) +
## create a separate plot for temperate and case counts
## let them set their own y-axes
facet_grid(measure ~ ., scales = "free_y") +
## plot both as a line
geom_line()
ts_data %>%
group_by(state) %>%
## keep the variables we are interested
select(date, cases, m_temp) %>%
## change your data in to long format
pivot_longer(
## use epiweek as your key
!date,
## move column names to the new "measure" column
names_to = "measure",
## move cell values to the new "values" column
values_to = "value") %>%
## create a plot with the dataset above
## plot epiweek on the x axis and values (counts/celsius) on the y
ggplot(aes(x = date, y = value)) +
## create a separate plot for temperate and case counts
## let them set their own y-axes
facet_grid(measure ~ ., scales = "free_y") +
## plot both as a line
geom_line()
ts_data %>%
## keep the variables we are interested
select(date, cases, m_humid) %>%
## change your data in to long format
pivot_longer(
## use epiweek as your key
!date,
## move column names to the new "measure" column
names_to = "measure",
## move cell values to the new "values" column
values_to = "value") %>%
## create a plot with the dataset above
## plot epiweek on the x axis and values (counts/celsius) on the y
ggplot(aes(x = date, y = value)) +
## create a separate plot for temperate and case counts
## let them set their own y-axes
facet_grid(measure ~ ., scales = "free_y") +
## plot both as a line
geom_line()
ts_data %>%
## keep the variables we are interested
select(date, cases, m_precip) %>%
## change your data in to long format
pivot_longer(
## use epiweek as your key
!date,
## move column names to the new "measure" column
names_to = "measure",
## move cell values to the new "values" column
values_to = "value") %>%
## create a plot with the dataset above
## plot epiweek on the x axis and values (counts/celsius) on the y
ggplot(aes(x = date, y = value)) +
## create a separate plot for temperate and case counts
## let them set their own y-axes
facet_grid(measure ~ ., scales = "free_y") +
## plot both as a line
geom_line()
#Installing package required for installing libraries
install.packages("pacman")
#Install libraries for data transformation
pacman::p_load(
rio,
here,
dplyr,
epikit,
forcats,
readr,
styler,
tidyverse,
janitor,
ggplot2,
corrr,
gtsummary,
broom,
kableExtra,
corrplot,
Hmisc,
feasts,
forecast,
tsibble
)
#Importing and viewing data------------------------------------------------------------------------
library(readxl)
timeseries <- read_excel("monthlydate_data.xlsx")
View(timeseries)
glimpse(timeseries)
timeseries <- timeseries %>%
clean_names() %>%
rename( m_tempmax = tempmax,
m_tempmin = tempmin,
m_temp = temp,
m_humid = humidity,
m_precip = precip,
m_precov = precipcover)
timeseries$state <- as.factor(timeseries$state)
timeseries$date <- as.Date(timeseries$date, format = "%Y-%m-%d")
timeseries$cases <- as.numeric(timeseries$cases)
glimpse(timeseries)
View(timeseries)
describe(ts_data)
timeseries %>%
## keep the variables we are interested
select(date, cases, m_humid) %>%
## change your data in to long format
pivot_longer(
## use epiweek as your key
!date,
## move column names to the new "measure" column
names_to = "measure",
## move cell values to the new "values" column
values_to = "value") %>%
## create a plot with the dataset above
## plot epiweek on the x axis and values (counts/celsius) on the y
ggplot(aes(x = date, y = value)) +
## create a separate plot for temperate and case counts
## let them set their own y-axes
facet_grid(measure ~ ., scales = "free_y") +
## plot both as a line
geom_line()
timeseries %>%
## keep the variables we are interested
select(date, cases, m_precip) %>%
## change your data in to long format
pivot_longer(
## use epiweek as your key
!date,
## move column names to the new "measure" column
names_to = "measure",
## move cell values to the new "values" column
values_to = "value") %>%
## create a plot with the dataset above
## plot epiweek on the x axis and values (counts/celsius) on the y
ggplot(aes(x = date, y = value)) +
## create a separate plot for temperate and case counts
## let them set their own y-axes
facet_grid(measure ~ ., scales = "free_y") +
## plot both as a line
geom_line()
timeseries %>%
# using an additive classical decomposition model
model(classical_decomposition(cases, type = "additive")) %>%
## extract the important information from the model
components() %>%
## generate a plot
autoplot()
timeseries_tsibble <- timeseries %>%
as_tsibble(index = month)
timeseries_tsibble <- timeseries %>%
as_tsibble(index = date)
duplicates(timeseries)
timeseries_tsibble <- timeseries %>%
as_tsibble(index = date)
duplicates <- timeseries %>%
group_by(date) %>%
filter(n() > 1)
# Print duplicates if any
print(duplicates)
# Handle duplicates if necessary (e.g., remove or aggregate)
# For this example, assume we need to sum cases for each date
timeseries <- timeseries %>%
group_by(date) %>%
summarise(cases = sum(cases, na.rm = TRUE))
# Convert to tsibble
timeseries_tsibble <- timeseries %>%
as_tsibble(index = date)
# Apply the classical decomposition model
decomposed_model <- timeseries_tsibble %>%
model(classical_decomposition(cases, type = "additive"))
# Extract the components
components <- decomposed_model %>%
components()
timeseries_tsibble <- timeseries %>%
as_tsibble(index = date)
# Apply the classical decomposition model
decomposed_model <- timeseries_tsibble %>%
model(classical_decomposition(cases, type = "additive"))
# Extract the components
components <- decomposed_model %>%
components()
duplicates <- timeseries %>%
group_by(date) %>%
filter(n() > 1)
# Print duplicates if any
print(duplicates)
# Handle duplicates if necessary (e.g., remove or aggregate)
timeseries <- timeseries %>%
group_by(date) %>%
summarise(cases = sum(cases, na.rm = TRUE))
# Convert to tsibble
timeseries_tsibble <- timeseries %>%
as_tsibble(index = date)
# Apply the classical decomposition model
decomposed_model <- timeseries_tsibble %>%
model(classical_decomposition(cases, type = "additive"))
# Check if the model fitting resulted in a null model
print(decomposed_model)
# If the model fitting is successful, proceed to extract components and plot
if (!is.null(decomposed_model)) {
components <- decomposed_model %>%
components()
duplicates <- timeseries %>%
group_by(date) %>%
filter(n() > 1)
# Print duplicates if any
print(duplicates)
# Handle duplicates if necessary (e.g., remove or aggregate)
timeseries <- timeseries %>%
group_by(date) %>%
summarise(cases = sum(cases, na.rm = TRUE))
# Convert to tsibble
timeseries_tsibble <- timeseries %>%
as_tsibble(index = date)
# Fill gaps in the time series
timeseries_tsibble <- timeseries_tsibble %>%
fill_gaps()
# Apply the classical decomposition model
decomposed_model <- timeseries_tsibble %>%
model(classical_decomposition(cases, type = "additive"))
# Check if the model fitting resulted in a null model
print(decomposed_model)
# If the model fitting is successful, proceed to extract components and plot
if (!is.null(decomposed_model)) {
components <- decomposed_model %>%
components()
print(decomposed_model)
duplicates <- timeseries %>%
group_by(date) %>%
filter(n() > 1)
# Print duplicates if any
print(duplicates)
# Handle duplicates if necessary (e.g., remove or aggregate)
timeseries <- timeseries %>%
group_by(date) %>%
summarise(cases = sum(cases, na.rm = TRUE))
# Convert to tsibble
timeseries_tsibble <- timeseries %>%
as_tsibble(index = date)
# Fill gaps in the time series
timeseries_tsibble <- timeseries_tsibble %>%
fill_gaps()
# Check the structure of the tsibble
print(timeseries_tsibble)
# Apply the classical decomposition model
decomposed_model <- timeseries_tsibble %>%
model(classical_decomposition(cases, type = "additive"))
# Check if the model fitting resulted in a null model
print(decomposed_model)
# Extract components and plot if the model is not null
if (!is.null(decomposed_model)) {
components <- decomposed_model %>%
components()
# Check the structure of the components
print(components)
# Generate the plot
autoplot(components)
} else {
print("Model fitting failed. Please check your data and the model specification.")
}
timeseries %>%
## keep the variables we are interested
select(date, cases, m_precip) %>%
## change your data in to long format
pivot_longer(
## use epiweek as your key
!date,
## move column names to the new "measure" column
names_to = "measure",
## move cell values to the new "values" column
values_to = "value") %>%
## create a plot with the dataset above
## plot epiweek on the x axis and values (counts/celsius) on the y
ggplot(aes(x = date, y = value)) +
## create a separate plot for temperate and case counts
## let them set their own y-axes
facet_grid(measure ~ ., scales = "free_y") +
## plot both as a line
geom_line() + theme_bw()
timeseries %>%
## keep the variables we are interested
select(date, cases, m_precip) %>%
## change your data in to long format
pivot_longer(
## use epiweek as your key
!date,
## move column names to the new "measure" column
names_to = "measure",
## move cell values to the new "values" column
values_to = "value") %>%
## create a plot with the dataset above
## plot epiweek on the x axis and values (counts/celsius) on the y
ggplot(aes(x = date, y = value)) +
## create a separate plot for temperate and case counts
## let them set their own y-axes
facet_grid(measure ~ ., scales = "free_y") +
## plot both as a line
geom_line() + theme_bw()
timeseries %>%
## keep the variables we are interested
select(date, cases, m_precip) %>%
## change your data in to long format
pivot_longer(
## use epiweek as your key
!date,
## move column names to the new "measure" column
names_to = "measure",
## move cell values to the new "values" column
values_to = "value") %>%
## create a plot with the dataset above
## plot epiweek on the x axis and values (counts/celsius) on the y
ggplot(aes(x = date, y = value)) +
## create a separate plot for temperate and case counts
## let them set their own y-axes
facet_grid(measure ~ ., scales = "free_y") +
## plot both as a line
geom_line(colour="red") + theme_bw()
mdata %>%
## keep the variables we are interested
select(month, cases, m_temp) %>%
## change your data in to long format
pivot_longer(
## use epiweek as your key
!month,
## move column names to the new "measure" column
names_to = "measure",
## move cell values to the new "values" column
values_to = "value") %>%
## create a plot with the dataset above
## plot epiweek on the x axis and values (counts/celsius) on the y
ggplot(aes(x = month, y = value)) +
## create a separate plot for temperate and case counts
## let them set their own y-axes
facet_grid(measure ~ ., scales = "free_y") +
## plot both as a line
geom_point() + geom_line()
pacman::p_load(
rio,
here,
dplyr,
epikit,
forcats,
readr,
styler,
tidyverse,
janitor,
ggplot2,
corrr,
gtsummary,
broom,
kableExtra,
corrplot,
Hmisc,
flextable,
officer
)
#Importing and viewing data------------------------------------------------------------------------
library(readxl)
monthly_data <- read_excel("mlfdata.xlsx")
View(monthly_data)
glimpse(monthly_data)
